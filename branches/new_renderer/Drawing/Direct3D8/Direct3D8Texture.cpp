#include "Direct3D8Texture.hpp"
#include "Direct3D8X.hpp"
#include "../ImageLoader.hpp"
#include "../../Misc/Exceptions.hpp"

namespace OSHGui
{
	namespace Drawing
	{
		static D3DFORMAT ToD3DPixelFormat(const Texture::PixelFormat format)
		{
			switch (format)
			{
				case Texture::PixelFormat::RGBA:
					return D3DFMT_A8R8G8B8;
				case Texture::PixelFormat::RGB:
					return D3DFMT_X8R8G8B8;
				case Texture::PixelFormat::RGB_565:
					return D3DFMT_R5G6B5;
				case Texture::PixelFormat::RGBA_4444:
					return D3DFMT_A4R4G4B4;
				case Texture::PixelFormat::RGBA_DXT1:
					return D3DFMT_DXT1;
				case Texture::PixelFormat::RGBA_DXT3:
					return D3DFMT_DXT3;
				case Texture::PixelFormat::RGBA_DXT5:
					return D3DFMT_DXT5;
				default:
					return D3DFMT_UNKNOWN;
			}
		}
		//---------------------------------------------------------------------------
		static uint32_t CalculateDataWidth(const uint32_t width, Texture::PixelFormat format)
		{
			switch (format)
			{
				case Texture::PixelFormat::RGBA:
					return width * 4;
				case Texture::PixelFormat::RGB:
					return width * 3;
				case Texture::PixelFormat::RGB_565:
				case Texture::PixelFormat::RGBA_4444:
					return width * 2;
				case Texture::PixelFormat::RGBA_DXT1:
					return ((width + 3) / 4) * 8;
				case Texture::PixelFormat::RGBA_DXT3:
				case Texture::PixelFormat::RGBA_DXT5:
					return ((width + 3) / 4) * 16;
				default:
					return 0;
			}
		}
		//---------------------------------------------------------------------------
		static void BlitRGBToBGRSurface(const uint8_t *src, uint8_t *dst, const SizeF &size)
		{
			for (auto i = 0; i < size.Height; ++i)
			{
				for (auto j = 0; j < size.Width; ++j)
				{
					*dst++ = src[2];
					*dst++ = src[1];
					*dst++ = src[0];
					src += 3;
				}
			}
		}
		//---------------------------------------------------------------------------
		void BlitRGBAToD3DCOLORSurface(const uint32_t *src, uint32_t *dst, const SizeF &size, uint32_t pitch)
		{
			for (auto i = 0; i < size.Height; ++i)
			{
				for (auto j = 0; j < size.Width; ++j)
				{
					auto pixel = src[j];
					auto tmp = pixel & 0x00FF00FF;
					dst[j] = pixel & 0xFF00FF00 | (tmp << 16) | (tmp >> 16);
				}

				dst += pitch / sizeof(uint32_t);
				src += static_cast<uint32_t>(size.Width);
			}
		}
		//---------------------------------------------------------------------------
		void BlitD3DCOLORSurfaceToRGBA(const uint32_t *src, uint32_t *dst, const SizeF &size, uint32_t pitch)
		{
			for (auto i = 0; i < size.Height; ++i)
			{
				for (auto j = 0; j < size.Width; ++j)
				{
					auto pixel = src[j];
					auto tmp = pixel & 0x00FF00FF;
					dst[j] = pixel & 0xFF00FF00 | (tmp << 16) | (tmp >> 16);
				}

				src += pitch / sizeof(uint32_t);
				dst += static_cast<uint32_t>(size.Width);
			}
		}
		//---------------------------------------------------------------------------
		class PixelBuffer
		{
		public:
			PixelBuffer(const void *data, const SizeF &size, Texture::PixelFormat format)
				: sourceBuffer(static_cast<const uint8_t*>(data)),
				  pitch(CalculateDataWidth(static_cast<size_t>(size.Width), format))
			{
				if (format == Texture::PixelFormat::RGBA || format == Texture::PixelFormat::RGB)
				{
					workBuffer.resize(pitch * static_cast<size_t>(size.Height));

					if (format == Texture::PixelFormat::RGBA)
					{
						BlitRGBAToD3DCOLORSurface(reinterpret_cast<const uint32_t*>(sourceBuffer), reinterpret_cast<uint32_t*>(workBuffer.data()), size, pitch);
					}
					else
					{
						BlitRGBToBGRSurface(sourceBuffer, workBuffer.data(), size);
					}
				}
			}
			//---------------------------------------------------------------------------
			size_t GetPitch() const
			{
				return pitch;
			}
			//---------------------------------------------------------------------------
			const uint8_t* GetPixelData() const
			{
				return !workBuffer.empty() ? workBuffer.data() : sourceBuffer;
			}
			//---------------------------------------------------------------------------

		private:
			const uint8_t* sourceBuffer;
			std::vector<uint8_t> workBuffer;
			uint32_t pitch;
		};
		//---------------------------------------------------------------------------
		//Constructor
		//---------------------------------------------------------------------------
		Direct3D8Texture::Direct3D8Texture(Direct3D8Renderer &_owner)
			: owner(_owner),
			  texture(nullptr),
			  size(0.0f, 0.0f),
			  dataSize(0.0f, 0.0f),
			  texelScaling(0.0f, 0.0f),
			  savedSurfaceDescValid(false)
		{

		}
		//---------------------------------------------------------------------------
		Direct3D8Texture::Direct3D8Texture(Direct3D8Renderer &_owner, const Misc::AnsiString &filename)
			: owner(_owner),
			  texture(nullptr),
			  texelScaling(0.0f, 0.0f),
			  savedSurfaceDescValid(false)
		{
			LoadFromFile(filename);
		}
		//---------------------------------------------------------------------------
		Direct3D8Texture::Direct3D8Texture(Direct3D8Renderer &_owner, const SizeF &_size)
			: owner(_owner),
			  texture(nullptr),
			  size(0.0f, 0.0f),
			  dataSize(size),
			  texelScaling(0.0f, 0.0f),
			  savedSurfaceDescValid(false)
		{
			CreateDirect3D8Texture(_size, D3DFMT_A8R8G8B8);
		}
		//---------------------------------------------------------------------------
		Direct3D8Texture::~Direct3D8Texture()
		{
			CleanupDirect3D8Texture();
		}
		//---------------------------------------------------------------------------
		//Getter/Setter
		//---------------------------------------------------------------------------
		void Direct3D8Texture::SetDirect3D8Texture(LPDIRECT3DTEXTURE8 _texture)
		{
			if (texture != _texture)
			{
				CleanupDirect3D8Texture();
				dataSize.Width = dataSize.Height = 0;

				texture = _texture;
				if (texture)
				{
					texture->AddRef();
				}
			}

			UpdateTextureSize();
			dataSize = size;
			UpdateCachedScaleValues();
		}
		//---------------------------------------------------------------------------
		LPDIRECT3DTEXTURE8 Direct3D8Texture::GetDirect3D8Texture() const
		{
			return texture;
		}
		//---------------------------------------------------------------------------
		const SizeF& Direct3D8Texture::GetSize() const
		{
			return size;
		}
		//---------------------------------------------------------------------------
		const SizeF& Direct3D8Texture::GetOriginalDataSize() const
		{
			return dataSize;
		}
		//---------------------------------------------------------------------------
		const std::pair<float, float>& Direct3D8Texture::GetTexelScaling() const
		{
			return texelScaling;
		}
		//---------------------------------------------------------------------------
		void Direct3D8Texture::SetOriginalDataSize(const SizeF& size)
		{
			dataSize = size;
			UpdateCachedScaleValues();
		}
		//---------------------------------------------------------------------------
		IDirect3DSurface8* Direct3D8Texture::GetTextureSurface() const
		{
			LPDIRECT3DSURFACE8 surface;
			if (FAILED(texture->GetSurfaceLevel(0, &surface)))
			{
				throw Misc::Exception();
			}

			return surface;
		}
		//---------------------------------------------------------------------------
		//Runtime-Functions
		//---------------------------------------------------------------------------
		void Direct3D8Texture::LoadFromFile(const Misc::AnsiString &filename)
		{
			auto imageData = LoadImageFromFileToRGBABuffer(filename);
			LoadFromMemory(imageData.Data.data(), imageData.Size, PixelFormat::RGBA);
		}
		//---------------------------------------------------------------------------
		void Direct3D8Texture::LoadFromMemory(const void *buffer, const SizeF &size, PixelFormat pixelFormat)
		{
			if (!IsPixelFormatSupported(pixelFormat))
			{
				throw Misc::NotSupportedException();
			}

			auto d3dFormat = ToD3DPixelFormat(pixelFormat);
			CreateDirect3D8Texture(size, d3dFormat);

			auto surface = GetTextureSurface();
			const PixelBuffer pixelBuffer(buffer, size, pixelFormat);

			const RECT rect = { 0, 0, size.Width, size.Height };

			auto hr = LoadSurfaceFromMemory(surface, nullptr, nullptr, pixelBuffer.GetPixelData(), d3dFormat == D3DFMT_X8R8G8B8 ? D3DFMT_R8G8B8 : d3dFormat, pixelBuffer.GetPitch(), nullptr, &rect, D3DX_FILTER_NONE, 0);

			surface->Release();

			if (FAILED(hr))
			{
				throw Misc::Exception();
			}
		}
		//---------------------------------------------------------------------------
		void Direct3D8Texture::CreateDirect3D8Texture(const SizeF &size, D3DFORMAT format)
		{
			CleanupDirect3D8Texture();

			auto textureSize = owner.GetAdjustedSize(size);

			//if (FAILED(D3DXCreateTexture(owner.GetDevice(), static_cast<UINT>(textureSize.Width), static_cast<UINT>(textureSize.Height), 1, 0, format, D3DPOOL_MANAGED, &texture)))
			if (FAILED(owner.GetDevice()->CreateTexture(static_cast<UINT>(textureSize.Width), static_cast<UINT>(textureSize.Height), 1, 0, format, D3DPOOL_MANAGED, &texture)))
			{
				throw Misc::Exception();
			}

			dataSize = size;
			UpdateTextureSize();
			UpdateCachedScaleValues();
		}
		//---------------------------------------------------------------------------
		void Direct3D8Texture::CleanupDirect3D8Texture()
		{
			if (texture)
			{
				texture->Release();
				texture = nullptr;
			}
		}
		//---------------------------------------------------------------------------
		void Direct3D8Texture::UpdateCachedScaleValues()
		{
			const float orgW = dataSize.Width;
			const float texW = size.Width;

			texelScaling.first = 1.0f / ((orgW == texW) ? orgW : texW);

			const float orgH = dataSize.Height;
			const float texH = size.Height;

			texelScaling.second = 1.0f / ((orgH == texH) ? orgH : texH);
		}
		//---------------------------------------------------------------------------
		void Direct3D8Texture::UpdateTextureSize()
		{
			D3DSURFACE_DESC description;
			if (texture && SUCCEEDED(texture->GetLevelDesc(0, &description)))
			{
				size.Width  = static_cast<float>(description.Width);
				size.Height = static_cast<float>(description.Height);
			}
			else
			{
				size = dataSize;
			}
		}
		//---------------------------------------------------------------------------
		void Direct3D8Texture::PreD3DReset()
		{
			if (savedSurfaceDescValid || !texture)
			{
				return;
			}

			texture->GetLevelDesc(0, &savedSurfaceDescription);

			if (savedSurfaceDescription.Pool == D3DPOOL_MANAGED)
			{
				return;
			}

			texture->Release();
			texture = nullptr;
			savedSurfaceDescValid = true;
		}
		//---------------------------------------------------------------------------
		void Direct3D8Texture::PostD3DReset()
		{
			if (!savedSurfaceDescValid)
			{
				return;
			}

			owner.GetDevice()->CreateTexture(savedSurfaceDescription.Width, savedSurfaceDescription.Height, 1, savedSurfaceDescription.Usage, savedSurfaceDescription.Format, savedSurfaceDescription.Pool, &texture);

			savedSurfaceDescValid = false;
		}
		//---------------------------------------------------------------------------
		bool Direct3D8Texture::IsPixelFormatSupported(const PixelFormat format) const
		{
			D3DDEVICE_CREATION_PARAMETERS parameters;
			owner.GetDevice()->GetCreationParameters(&parameters);

			LPDIRECT3D8 d3d;
			owner.GetDevice()->GetDirect3D(&d3d);

			D3DDISPLAYMODE displayMode;
			d3d->GetAdapterDisplayMode(parameters.AdapterOrdinal, &displayMode);

			auto d3dFormat = ToD3DPixelFormat(format);

			if (d3dFormat == D3DFMT_UNKNOWN)
			{
				return false;
			}

			return SUCCEEDED(d3d->CheckDeviceFormat(parameters.AdapterOrdinal, parameters.DeviceType, displayMode.Format, 0, D3DRTYPE_TEXTURE, d3dFormat));
		}
		//---------------------------------------------------------------------------
	}
}
